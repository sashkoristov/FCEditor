## Skype Conference, June 14th

### General
- The overall goal of DPS in this topic is :
    - "rebuild askalon for serverless"
    - run workflow on multiple cloud providers
        - ex. func1 is in amazon (Java), func2 is in IBM (PHP)
    - composition of workflow on high level of abstraction
 
- build (and deploy) a function can only a developer

- Enacment Engine: Stupid Executor: Just run the stuff with monitoring

### Thesis

- "it's not only a gui, it is also research"
- not part of this thesis:
    - scheduler (will be done by dps)
    - updating the API

##### Frontend (the GUI)
- is engineering work
- uses the API
- composition logic of workflow should be like in askalon (UML standards)
- should allow to select target system
- if not, let the system select where to run
- Technology choice is free

- After Composition: Button "Run it"
    - based on selected functions workflow is executed
    - can select only functions for which implementations are available

- needs a database function repository with metadata for the functions
    - quota limits, where is it deployed, ...
    - example:
        * func1 deployed in Amazon with language 1
        * func2 deployed in IBM with language 2

##### Backend (optimization part)

- Technology Requirement: Java
- Input file: AFCL
    - dataInput and dataOutputs connection, each function where it runs
- Output file: CFCL (= "ACFL + optimizations")
- Examples
    - for provider limits:
        * parallel loop with 1000 functions
        (1000 passengers on airport, find location for each of them;
        if the passenger has moved security check, no information is sent
        if the passenger is before security check, send info to passenger)
    
        * scheduler decides best case:
            - 800 in Google
            - 200 in Amazon

    - for reducing network latency ("move the data closer to where it is needed")
        * func1 is in Amazon, then parallel 1000 iterations of func2 in IBM;
        each instance of function in IBM needs the output of amazon func
        * middleware function: move output of func1 to IBM cloud, then start parallel section
    
    - another example
        * Three functions one after another: func1 -> func2 -> func3 in AFCL.
          func3 needs output of func1
          In CFCL, possible ways for this are:
            - output of func1 is moved to S3, func3 references on S3
            - func2 just passes the output of func1 to the input of func3

